#!/usr/bin/env python3
import sys
import yaml
import time
import rospy
import numpy as np
from std_msgs.msg import Float32
from geometry_msgs.msg import PoseStamped
from record_joint_states_dataset import JointStatesRecorder
import rospkg
import os
import argparse
import panda_py
import dynamic_reconfigure.client


class JointStatesRecorderPanda(JointStatesRecorder):
    def __init__(self, joint_state_topic_name: str, folder_name: str, config: dict):
        super().__init__(joint_state_topic_name, folder_name, 7)
        self._pykeyboard.stop()
        hostname = config['hostname']
        username = config['username']
        password = config['password']
        self.desk = panda_py.Desk(hostname, username, password)
        self.desk.listen(self._on_press_panda)
        self.vibration_pub = rospy.Publisher("/haptic_feedback", Float32, queue_size=0)
        self.pose_subsciber = rospy.Subscriber("/cartesian_pose", PoseStamped, self._pose_callback)
        self._last_time_pressed = rospy.Time.now()
        self._pose = np.zeros(7)
        self.set_K = dynamic_reconfigure.client.Client('/dynamic_reconfigure_compliance_param_node', config_callback=None)
        self.set_K.update_configuration({"translational_stiffness_X": 0})
        self.set_K.update_configuration({"translational_stiffness_Y": 0})
        self.set_K.update_configuration({"translational_stiffness_Z": 0})
        self.set_K.update_configuration({"rotational_stiffness_X": 0}) 
        self.set_K.update_configuration({"rotational_stiffness_Y": 0}) 
        self.set_K.update_configuration({"rotational_stiffness_Z": 0})

    def _pose_callback(self, pose: PoseStamped) -> None:
        self._pose = np.array([
                pose.pose.position.x, 
                pose.pose.position.y, 
                pose.pose.position.z, 
                pose.pose.orientation.w, 
                pose.pose.orientation.x, 
                pose.pose.orientation.y, 
                pose.pose.orientation.z, 
        ])

    def vibrate(self, duration=0.2, times=1):
        # self.log(f"Vibrating for {duration} seconds {times} times.")
        for _ in range(times):
            self.vibration_pub.publish(Float32(data=duration))
            time.sleep(duration*2)

    def _on_press_panda(self, event: dict) -> None:
        time_since_last_press = (rospy.Time.now() - self._last_time_pressed).to_sec()
        if time_since_last_press < 0.6:
            return
        self._last_time_pressed = rospy.Time.now()
        
        if 'check' in event and event['check']: 
            self._data[self.hole_name()].append(self._positions)
            self._data[f"{self.hole_name()}_pose"].append(self._pose)


            self.log(f"Addded data point for {self.hole_name()} with value {self._positions}")
            self.vibrate()
            if len(self._data[self.hole_name()]) == 30:
                self.vibrate(duration=0.1, times=3)
        elif 'down' in event and event['down']:
            self._data[self.hole_name()] = self._data[self.hole_name()][0:-1]
            self.log(f"Deleted data point for {self.hole_name()}")
            self.vibrate()
        elif 'cross' in event and event['cross']:
            self.log("Saving data to file and exiting")
            self.save_data()
            self.vibrate()
            return
        elif 'circle' in event and event['circle']:
            self._active_hole = (self._active_hole + 1) % 2
            self.log(f"Switched to hole {self._active_hole}")
            self.vibrate(duration=0.1, times=2)
        else:
            self.log("Unknown key pressed")
        self.print_status()

    def print_info(self):
        self.log("Press 'check' to add a data point")
        self.log("Press 'down' to delete the last data point")
        self.log("Press 'o' to switch between holes")
        self.log("Press 'x' to save the data and quit.")




if __name__ == "__main__":
    argument_parser = argparse.ArgumentParser(description='Run the parameter optimizer')
    argument_parser.add_argument("--joint-state-topic-name", "-j", help="Topic where the joint state is published")
    argument_parser.add_argument("--robot-name", "-r", help="name of the robot that you are calibrating, e.g. panda_4")
    argument_parser.add_argument("--tool-position-on-table", "-t", help="postion of the tool on the table for the franka")
    argument_parser.add_argument("--config-file", "-c", help="config file with the ip, admin and password of the robots")



    args = argument_parser.parse_args()
    joint_state_topic_name = args.joint_state_topic_name
    robot_name = args.robot_name
    config_file = args.config_file
    tool_position = args.tool_position_on_table
    package=os.path.join(rospkg.RosPack().get_path('calibration_tools'))
    data_folder =  os.path.join(package, os.pardir, os.pardir, os.pardir, 'data', robot_name, tool_position) 
    print(data_folder)
    print("Joint_state", joint_state_topic_name)
    print("Robot name:",robot_name)
    config_path = os.path.join(package, 'config', config_file)
    print("Config file:",config_path)
    config = yaml.load(open(config_path, 'r'), Loader=yaml.FullLoader)
    node = JointStatesRecorderPanda(joint_state_topic_name, data_folder, config)
    try:
        node.run()
    except rospy.ROSInterruptException:
        pass

